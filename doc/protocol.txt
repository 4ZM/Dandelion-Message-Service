
                   DANDELION MESSAGE SERVICE 
                    PROTOCOL DESIGN DOCUMENT
					
                      Draft version 1.0

					  
  This document enumerates the terms and the data in the Dandelion domain. It also includes the specification of the Dandelion communication protocol, used for data transfer between nodes.					  
					   
					   
Abstract User Identity Syntax
=============================

Data Base:
DBID : Data Base ID. A random 96 bit (12 byte) number that will uniquely identify a data base. The id is generated by the nodes.

  TODO: How to prevent adversary from duplicating and messing with time cookies? Identity signing? Vouch for db by signing it's id? This would allow a web of trust.

Public user identity:
Identifies one unique individual or organization that can establish afk trust relationships. It contains the fingerprint and public key parts of the encryption and signing keys.

UIDFP  : The least significant 96 bit (12 bytes) of the SHA256 of the public signing and encryption keys. Since it can be deterministically generated from the key pair, it can also be used to verify data integrity.
PUBSGN : Public signing key, 1024 bit DSA. It consists of the integer components [y,g,p,q]
PUBENC : Public encryption key, 2048 bit RSA. It consists of the integer components [n,e]

Private user identity:
Is the same as the public identity but with additional private keys (fingerprint is the same - it's only computed from public keys).

UIDFP   : Same as for the public id.
PUBSGN  : Same as for the public id.
PUBENC  : Same as for the public id.
PRIVSGN : Private signing key, 1024 bit DSA. It consists of an integer [x].
PRIVENC : Private encryption key, 2048 bit RSA. It consists of an integer [d].

Ref.
[1] https://secure.wikimedia.org/wikipedia/en/wiki/Birthday_problem


Abstract Message Syntax
=======================

There are four types of messages as described by MS.1 to MS.4. 

MS.1) Message without sender or receiver.

MSGID   : Message ID. The least significant 96 bits (12 bytes) of the SHA256 of the remaining fields in the message. A number that uniquely identifies this message. Since it can be deterministically generated from the message, it can also be used to verify data integrity.
MSG     : Message payload. Text string 

TBD: Should we extend message content?
TBD: Should we support message fragmentation (larger messages)?

Typical command: "Say" -> [MSGID][MSG] 

MS.2) Message with sender but without receiver.

MSGID    : Same as in MS.1 but hash also includes the SENDERID and SIGN fields.
MSG      : Same as in MS.1 
SENDERID : Sender ID fingerprint (UIDFP).
SIGN     : Signature of MSG (not SENDERID or MSGID).

Typical command: "ISay" -> [MSGID][MSG][SENDERID][SIGN]

MS.3) Message with receiver but without sender.

MSGID   : Same as in MS.1 but hash also includes the RECVID field.
MSG     : Same as in MS.1. This is the unencrypted text (not included explicitly in the MS.3 message). 
#MSG#   : The MSG encrypted with the recipients public encryption key.
RECVID  : Receiver ID fingerprint (UIDFP).

Typical command: "SayTo" -> [MSGID][#MSG#][RECVID]

Note.3.1 :  Requirements on message length, allowed characters, etc. apply to the MSG (implicit) string. They are not applicable to the #MSG# string. 
Note.3.2 :  There is no point in using the more than fingerprint as the recipient field since that is enough information for one specific node to identifying the message as hers. The message will be meaningless for all other nodes.

MS.4) Message with both sender and receiver.

MSGID      : Same as in MS.1 but also includes the SENDERID, SIGN and RECVID fields.
MSG        : Same as in MS.3
#MSG#      : Same as in MS.3
RECVID     : Same as in MS.3
SENDERID   : Same as in MS.2
SIGN       : Same as in MS.2. Signature of MSG (not #MSG#, RECVID, SENDERID or MSGID).

Typical command: "ISayTo" -> [MSGID][#MSG#][RECVID][SENDERID][SIGN]

TBD) The SENDER, SIGN should also be included in the the cipher text. Only receiver needs to know the sender. This might otherwise open for trafic analysis attacks mapping communication channels.


Communication Protocol
======================

This section describes the DMS communication protocol version 1.0

It is a stateless, constrained RESTful[1] protocol.

All data is transmitted as plain text UTF-8 encoded strings without BOM.

A note to implementers. Malformed messages, unexpected or infinite data streams, client or server disconnects must never put either the client or the server in an inconsistent state and must not significantly effect the concurrent communication with other clients or servers.

Ref.
[1]	http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm

Communicaion Transactions:

CT.1)

Connect and greeting. The server sends the greeting message upon connection from a client.

   [C]                                                    [S]
    |                                                      | 
    |                       connect                        | 
    |----------------------------------------------------->| 
    |                                                      | 
    |     <protocol cookie>;<protocol version>;<db id>     | 
    |<-----------------------------------------------------| 
    |                                                      | 
    |                                                      | 

Data Specification: 
  Fileld separator     : ';' (semicolon)
  <protocol cookie>    : The exact string 'DMS'. Identifies the protocol as Dandelion Message Service.
  <protocol version>   : A string of format [0-9]+\.[0-9]+ where numbers and the point are UTF-8 (ASCII) characters. 
  <db id>              : A Base64 representation of the DBID

CT.2)

The client requests a list of the servers message. This could be a complete or partial listing. If the client has not previously synchronized with the server, it will request a complete list by omitting the <time cookies> field.

   [C]                                                    [S]
    |                                                      | 
    |             GETMESSAGELIST [<time cookie>]           | 
    |----------------------------------------------------->| 
    |                                                      | 
    |       <time cookie>;<msgid>;<msgid>;...;<msgid>      | 
    |<-----------------------------------------------------| 
    |                                                      | 
    |                                                      | 

Data Specification: 
  Fileld separator  : ';' (semicolon)
  <time cookie>     : A Base64 string (preferably short) that represents a moment in time for the server. Think of it as a revision number.
  <msgid>           : An Base64 representation of the MSGID

Note.2.1 If there are no messages on the server since <time cookie> it should respond with only a new <time cookie>
Note.2.2 If the server can not parse the <time cookie>, it should hang up the connection. (TBD is this what we want?).

CT.3)

The client requests one or more messages from the server by asking for them using their MSGIDs. 
	
   [C]                                                    [S]
    |                                                      | 
    |    GETMESSAGES [[[<msgid>];<msgid>];...;<msgid>]     | 
    |----------------------------------------------------->| 
    |                                                      | 
    |              <msg>;<msg>;...;<msg>;                  | 
    |<-----------------------------------------------------| 
    |                                                      | 
    |                                                      | 

Data Specification: 
  Fileld separator  : ';' (semicolon)
  <msgid>           : A Base64 representation of the MSGID
  <msg>             : A string describing a message (see below).


Message encoding for the communication protocol:
Fileld separator  : '|' (pipe)

  MSGLEN    : Base64 representation of payload data size in bytes (0 is an empty message)
  MSG       : MSGLEN bytes of data. Base64 encoded. 
  #MSG#     : MSGLEN bytes of binary data. Base64 encoded.
  RECVID    : 96 bit UIDFP encoded as Base64 string 
  SENDERID  : 96 bit UIDFP encoded as Base64 string 
  SIGN      : Base64 encoded signature
	
Note.3.1 The message id is not send since it is can be derived from the content
Note.3.2 The client can not assume that the messages that are sent by the server are the same (or the same number) as the ones requested. For cooperative servers, this will typically be the case, but messages could have been removed from the server database between GETMESSAGELIST and GETMESSAGES request. The server could also be an adversary trying to disrupt communications.



CT.4)

The client requests a list of the servers user id fingerprints. This could be a complete or partial listing. If the client has not previously synchronized with the server, it will request a complete list by omitting the <time cookies> field.

   [C]                                                    [S]
    |                                                      | 
    |           GETIDENTITYLIST [<time cookie>]            | 
    |----------------------------------------------------->| 
    |                                                      | 
    |    <time cookie>;<uid fp>;<uid fp>;...;<uid fp>      | 
    |<-----------------------------------------------------| 
    |                                                      | 
    |                                                      | 

Data Specification: 
  Fileld separator  : ';' (semicolon)
  <time cookie>     : A Base64 encoded string (preferably short) that represents a moment in time for the server.
  <uid fp>          : A Base64 encoded representation of the UIDFP

Note.2.1 If there are no new uids on the server since <time cookie> it should respond with only a new <time cookie> (possibly the same).
Note.2.2 If the server can not parse the <time cookie>, it should hang up the connection.

CT.5)

The client requests one or more UIDs from the server by asking for them using their UIDFPs. 
	
   [C]                                                    [S]
    |                                                      | 
    |  GETIDENTITIES [[[<uid fp>];<uid fp>];...;<uid fp>]  | 
    |----------------------------------------------------->| 
    |                                                      | 
    |              <uid>;<uid>;...;<uid>;                  | 
    |<-----------------------------------------------------| 
    |                                                      | 
    |                                                      | 

Data Specification: 
  Fileld separator  : ';' (semicolon)
  <uid fp>          : A Base64 encoded representation of the UIDFP
  <uid>             : A string describing a UID (see below).


UID encoding for the communication protocol:
Fileld separator  : '|' (pipe)

  UIDFP   : UIDFP 96 bit (12 bytes) encoded as Base64
  PUBSGN  : Base64 representation of the public signing key components [y,g,p,q]
  PUBENC  : Base64 representation of the public encryption key components [n,e]


Appendix. Fingerprint considerations

Here are some considerations on fingerprint and hash size. The problem of finding an appropriate size can be modelled using the birthday problem.[1] The probability of at least one collision when drawing n numbers from a uniformly distributed set of size 2^b is: 
p(n,b) = 1 - n! * (Binomial(2^b, n) / 2^(b * n))

Samples:
n         b=64       b=96     b=128
0.01E6    2.71E-12   6.3E-22  -
0.10E6    2.71E-10   6.3E-20  1.47E-29
1.00E6    2.71E-8    6.3E-18  1.47E-27

It seems that 96 bit (12 byte) hashes are a good fit for our typical domain of n's. Using the full SHA256 256 bits would be overkill. 

To put this in perspective. 80 people die every year in the US (population ~250M) after being struck by lightning. That probability is 0.32e-6. The probability of you and your girfriend both being hit by lightning, independenty of each other, is 0.10e-12. The probability of you, your girfriend and her mother all getting hit by lightning, independenty of each other, is 0.03e-18.
